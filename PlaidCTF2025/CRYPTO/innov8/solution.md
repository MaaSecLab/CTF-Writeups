

# Part 1 â†’ EXCAV8

### Challenge Description
> **"Remember the past."**  
Solving this gives the password for part 2's server and handout.

### Provided Files:
- `chall.py`
- `d8`
- `Dockerfile`
- `gen.js`
- `output.txt`

---

### Solution

First, we analyze all the files provided to gather as much information as possible. To understand what is required from us, the main focus is on the `chall.py` and `gen.js` files.

#### `chall.py`
```python
import subprocess

secret = open('secret.txt').read().strip()
secretbits = ''.join(f'{ord(i):08b}' for i in secret)

output = []

for bit in secretbits:
    if bit == '0':
        output += [float(i) for i in subprocess.check_output('./d8 gen.js', shell=True).decode().split()]
    else:
        output += [float(i) for i in subprocess.check_output('node gen.js', shell=True).decode().split()]

for i in output:
    print(i)
```

In the Python code, we observe how `output.txt` is created. We can assume that `secret.txt` contains the flag. From there, we see it gets translated into binary.

- If the bit at position `i` is **0**, the program appends data from running `gen.js` through the **d8** engine.
- Otherwise, it appends the output of `gen.js` when run through **node**.

#### `gen.js`
```javascript
for (let i = 0; i < 24; i++) {
    console.log(Math.random());
}
```

In the JavaScript code, we see `gen.js` generates chunks of 24 floats using `Math.random()`, which is our first clue â€” PRNGs are often vulnerable when implemented poorly.

---

###  The Insight

After some research, we found that **d8â€™s PRNG state can be reversed** if we gather a sequence of consecutive numbers generated by it.

To avoid reinventing the wheel during the CTF, we searched GitHub and found this existing tool:

ðŸ‘‰ [v8-randomness-predictor](https://github.com/PwnFunction/v8-randomness-predictor)  
*(Credits to [PwnFunction](https://github.com/PwnFunction))*

This tool uses the **Z3 solver** to find the internal `s0` and `s1` states for the v8 (Chromium) engine. The algorithm differs slightly from the one used by **node.js**, so the tool helps us distinguish between the two.

###  Strategy

We modified the tool to print:
- `0` if the states were **found** (i.e., **d8** was used),
- `1` otherwise (i.e., **node** was used).

---

###  Solve Script

```python
#!/usr/bin/python3
import z3
import struct

def check_sequence(sequence):
    sequence = sequence[::-1]
    solver = z3.Solver()
    se_state0, se_state1 = z3.BitVecs("se_state0 se_state1", 64)

    for i in range(len(sequence)):
        se_s1 = se_state0
        se_s0 = se_state1
        se_state0 = se_s0
        se_s1 ^= se_s1 << 23
        se_s1 ^= z3.LShR(se_s1, 17)
        se_s1 ^= se_s0
        se_s1 ^= z3.LShR(se_s0, 26)
        se_state1 = se_s1

        float_64 = struct.pack("d", sequence[i] + 1)
        u_long_long_64 = struct.unpack("<Q", float_64)[0]
        mantissa = u_long_long_64 & ((1 << 52) - 1)

        solver.add(int(mantissa) == z3.LShR(se_state0, 12))

    return 1 if solver.check() == z3.sat else 0

with open("output.txt") as f:
    floats = [float(x.strip()) for x in f.readlines()]

for i in range(0, len(floats), 24):
    chunk = floats[i:i+24]
    if len(chunk) < 24:
        break
    print(check_sequence(chunk))
```

Converting the binary output to ASCII, we get the following:
```
flag: PCTF{BuilD1nG_v8_i5_SuCh_4_pa1N...}
password to part 2: oaq1MD92evRsDZvH
```
